"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ButtonPaginationBuilder = void 0;
const discord_js_1 = require("discord.js");
const buttons_1 = require("../../types/buttons");
const enums_1 = require("../../types/enums");
const BasePagination_1 = require("../BasePagination");
class ButtonPaginationBuilder extends BasePagination_1.BasePagination {
    _buttons = [];
    _onDisable = buttons_1.ButtonsOnDisable.DisableComponents;
    _singlePageNoButtons = true;
    _collector = null;
    _collectorOptions;
    get buttons() { return this._buttons; }
    get onDisable() { return this._onDisable; }
    get singlePageNoButtons() { return this._singlePageNoButtons; }
    get collector() { return this._collector; }
    get collectorOptions() { return this._collectorOptions; }
    constructor(options) {
        options = options.toJSON !== undefined
            ? options.toJSON()
            : options;
        super(options);
        this.setButtons(...(options?.buttons ?? []));
        this.setOnDisable(options?.onDisable ?? this.onDisable);
        this.setSinglePageNoButtons(options?.singlePageNoButtons ?? this.singlePageNoButtons);
        this.setCollectorOptions(options?.collectorOptions ?? this.collectorOptions);
    }
    /**
     * Add button controller to pagination
     * @param button Button data or builder
     * @param type Controller type
     */
    addButton(button, type) {
        this._buttons.push(ButtonPaginationBuilder.resolveButton({
            builder: button,
            type
        }));
        return this;
    }
    /**
     * Set button controllers
     * @param buttons Button controllers data
     */
    setButtons(...buttons) {
        this._buttons = (0, discord_js_1.normalizeArray)(buttons).map(b => ButtonPaginationBuilder.resolveButton(b));
        return this;
    }
    /**
     * Action on disable
     * @param onDisable on disable action
     */
    setOnDisable(onDisable) {
        this._onDisable = (0, enums_1.getEnumValue)(buttons_1.ButtonsOnDisable, onDisable);
        return this;
    }
    /**
     * Disable pagination controllers with single page pagination
     * @param singlePageNoButtons single page no buttons
     */
    setSinglePageNoButtons(singlePageNoButtons) {
        this._singlePageNoButtons = !!singlePageNoButtons;
        return this;
    }
    /**
     * Custom collector options
     * @param collectorOptions collector options
     */
    setCollectorOptions(collectorOptions) {
        this._collectorOptions = collectorOptions || undefined;
        return this;
    }
    async paginate(command, sendAs = enums_1.SendAs.ReplyMessage) {
        if (this.isSent())
            throw new Error(`Pagination is already sent`);
        if (!this.pages.length)
            throw new Error(`Pagination does not have any pages`);
        this._command = command;
        this._paginationComponent = new discord_js_1.ActionRowBuilder()
            .setComponents(this.buttons.map(b => b.builder));
        if (this.pages.length <= 1 && this.singlePageNoButtons)
            this._removePaginationComponents = true;
        await this._sendPage((await this.currentPage), (0, enums_1.getEnumValue)(enums_1.SendAs, sendAs));
        this.emit('ready');
        this._addCollector();
        return this;
    }
    isSent() {
        return super.isSent();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            buttons: this.buttons,
            onDisable: this.onDisable,
            singlePageNoButtons: this.singlePageNoButtons,
            collectorOptions: this.collectorOptions
        };
    }
    _addCollector() {
        if (!this.isSent())
            throw new Error(`Pagination is not ready`);
        this._collector = this.pagination.createMessageComponentCollector({
            ...this.collectorOptions,
            time: this.timer
        });
        this.collector.on('collect', async (component) => {
            this.emit('collect', component);
            if (!component.isButton())
                return;
            if (this.authorDependent && this.authorId && this.authorId !== component.user.id)
                return;
            const button = this.buttons.find(b => b.builder.data.custom_id === component.customId);
            if (!button)
                return;
            switch (button.type) {
                case enums_1.PaginationControllerType.FirstPage:
                    await this.setCurrentPage(0).catch(() => { });
                    break;
                case enums_1.PaginationControllerType.PreviousPage:
                    this.setCurrentPage(this.previousPageIndex).catch(() => { });
                    break;
                case enums_1.PaginationControllerType.NextPage:
                    this.setCurrentPage(this.nextPageIndex).catch(() => { });
                    break;
                case enums_1.PaginationControllerType.LastPage:
                    await this.setCurrentPage(this.pages.length - 1).catch(() => { });
                    break;
                case enums_1.PaginationControllerType.Stop:
                    this._collector?.stop('PaginationEnded');
                    break;
            }
            this.emit('interactionCreate', component, button);
            this._collector?.resetTimer();
            if (!component.deferred)
                await component.deferUpdate().catch(() => { });
        });
        this.collector.on('end', async (collected, reason) => {
            this.emit('end', reason);
            switch (this.onDisable) {
                case buttons_1.ButtonsOnDisable.RemoveComponents:
                    this._removeAllComponents = true;
                    await this.setCurrentPage(undefined, true).catch(() => { });
                    break;
                case buttons_1.ButtonsOnDisable.DisableComponents:
                    this._disableAllComponents = true;
                    await this.setCurrentPage(undefined, true).catch(() => { });
                    break;
                case buttons_1.ButtonsOnDisable.DeletePagination:
                    if (this.command instanceof discord_js_1.Message) {
                        await this.pagination?.delete().catch(() => { });
                    }
                    else {
                        await this.command?.deleteReply().catch(() => { });
                    }
                    break;
            }
        });
    }
    static resolveButton(button) {
        if (!(button.builder instanceof discord_js_1.ButtonBuilder))
            button.builder = new discord_js_1.ButtonBuilder(button.builder);
        if (button.builder.data.style === discord_js_1.ButtonStyle.Link)
            throw new Error(`Link button is not usable as pagination controller`);
        return {
            builder: button.builder,
            type: (0, enums_1.getEnumValue)(enums_1.PaginationControllerType, button.type)
        };
    }
}
exports.ButtonPaginationBuilder = ButtonPaginationBuilder;
//# sourceMappingURL=ButtonPaginationBuilder.js.map