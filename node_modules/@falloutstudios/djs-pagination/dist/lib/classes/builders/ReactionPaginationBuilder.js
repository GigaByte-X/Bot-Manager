"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReactionPaginationBuilder = void 0;
const discord_js_1 = require("discord.js");
const index_1 = require("../../index");
const reactions_1 = require("../../types/reactions");
const BasePagination_1 = require("../BasePagination");
class ReactionPaginationBuilder extends BasePagination_1.BasePagination {
    _reactions = [];
    _onDisable = reactions_1.ReactionsOnDisable.ClearPaginationReactions;
    _singlePageNoReactions = true;
    _collector = null;
    _collectorOptions;
    get reactions() { return this._reactions; }
    get onDisable() { return this._onDisable; }
    get singlePageNoReactions() { return this._singlePageNoReactions; }
    get collector() { return this._collector; }
    get collectorOptions() { return this._collectorOptions; }
    constructor(options) {
        options = options.toJSON !== undefined
            ? options.toJSON()
            : options;
        super(options);
        this.setReactions(...(options.reactions ?? []));
        this.setOnDisable(options.onDisable ?? this.onDisable);
        this.setSinglePageNoReactions(options.singlePageNoReactions ?? this.singlePageNoReactions);
    }
    /**
     * Add reaction controller to pagination
     * @param emoji Emoji resolvable
     * @param type Controller type
     */
    addReaction(emoji, type) {
        this._reactions.push(ReactionPaginationBuilder.parseReaction({ emoji, type }));
        return this;
    }
    /**
     * Replace all reaction controllers in pagination
     * @param reactions Reaction controllers
     */
    setReactions(...reactions) {
        this._reactions = (0, discord_js_1.normalizeArray)(reactions).map(r => ReactionPaginationBuilder.parseReaction(r));
        return this;
    }
    /**
     * Action on disable
     * @param onDisable on disable action
     */
    setOnDisable(onDisable) {
        this._onDisable = (0, index_1.getEnumValue)(reactions_1.ReactionsOnDisable, onDisable);
        return this;
    }
    /**
     * Disable reaction controllers on single page pagination
     * @param singlePageNoReactions single page no reactions
     */
    setSinglePageNoReactions(singlePageNoReactions) {
        this._singlePageNoReactions = !!singlePageNoReactions;
        return this;
    }
    /**
     * Custom collector options
     * @param collectorOptions collector options
     */
    setCollectorOptions(collectorOptions) {
        this._collectorOptions = collectorOptions;
        return this;
    }
    async paginate(command, sendAs = index_1.SendAs.ReplyMessage) {
        if (this.isSent())
            throw new Error(`Pagination is already sent`);
        if (!this.pages.length)
            throw new Error(`Pagination does not have any pages`);
        if (!new discord_js_1.IntentsBitField(command.client.options.intents).has("GuildMessageReactions"))
            throw new Error("Missing intent 'GuildMessageReactions'");
        this._command = command;
        const page = await this.currentPage;
        if (!(command instanceof discord_js_1.Message) && (command.ephemeral === true || command.ephemeral === null && page?.ephemeral))
            throw new Error("Reactions cannot be added to ephemeral messages");
        await this._sendPage(page, (0, index_1.getEnumValue)(index_1.SendAs, sendAs));
        await this._react();
        this.emit('ready');
        this._addCollector();
        return this;
    }
    isSent() {
        return super.isSent();
    }
    toJSON() {
        return {
            ...super.toJSON(),
            reactions: this.reactions,
            onDisable: this.onDisable,
            singlePageNoReactions: this.singlePageNoReactions,
            collectorOptions: this.collectorOptions
        };
    }
    _addCollector() {
        if (!this.isSent())
            throw new Error(`Pagination is not ready`);
        this._collector = this.pagination.createReactionCollector({
            ...this.collectorOptions,
            time: this.timer
        });
        this.collector.on('collect', async (reaction, user) => {
            this.emit('collect', reaction);
            if (this.authorDependent && this.authorId && this.authorId !== user.id)
                return;
            const controller = this.reactions.find(b => (reaction.emoji.id ?? null) === b.id && (reaction.emoji.name ?? null) === b.name);
            if (!controller)
                return;
            switch (controller.type) {
                case index_1.PaginationControllerType.FirstPage:
                    await this.setCurrentPage(0).catch(() => { });
                    break;
                case index_1.PaginationControllerType.PreviousPage:
                    this.setCurrentPage(this.previousPageIndex).catch(() => { });
                    break;
                case index_1.PaginationControllerType.NextPage:
                    this.setCurrentPage(this.nextPageIndex).catch(() => { });
                    break;
                case index_1.PaginationControllerType.LastPage:
                    await this.setCurrentPage(this.pages.length - 1).catch(() => { });
                    break;
                case index_1.PaginationControllerType.Stop:
                    this._collector?.stop('PaginationEnded');
                    break;
            }
            this.emit('reactionAdd', reaction, controller);
            this._collector?.resetTimer();
            reaction.users.remove(user).catch(() => { });
        });
        this.collector.on('end', async (collected, reason) => {
            this.emit('end', reason);
            switch (this.onDisable) {
                case reactions_1.ReactionsOnDisable.ClearAllReactions:
                    await this.pagination?.reactions.removeAll().catch(() => { });
                    break;
                case reactions_1.ReactionsOnDisable.ClearPaginationReactions:
                    for (const reaction of this.pagination?.reactions.cache.filter(r => r.me).toJSON() ?? []) {
                        await reaction.remove().catch(() => { });
                    }
                    break;
                case reactions_1.ReactionsOnDisable.DeletePagination:
                    if (this.pagination?.deletable)
                        await this.pagination.delete().catch(() => { });
                    break;
            }
        });
    }
    async _react() {
        if (!this.isSent())
            throw new TypeError("Pagination is not yet ready");
        if (this.pages.length <= 1 && this.singlePageNoReactions)
            return;
        for (const emojiData of this._reactions) {
            const emoji = emojiData.id === null ? emojiData.name : this.pagination.client.emojis.cache.get(emojiData.id);
            if (!emoji)
                throw new Error("Could not find emoji cache for " + emojiData.id ?? emojiData.name);
            await this.pagination.react(emoji);
        }
    }
    static parseReaction(reaction) {
        if (reaction?.id !== undefined || reaction?.name !== undefined)
            return reaction;
        const parsedEmoji = (0, discord_js_1.parseEmoji)(reaction.emoji);
        if (!parsedEmoji?.id && !parsedEmoji?.name || !parsedEmoji?.name || parsedEmoji.animated && !parsedEmoji.id)
            throw new Error(`Couldn't parse emoji`);
        return {
            id: parsedEmoji.id ?? null,
            name: parsedEmoji.name,
            type: (0, index_1.getEnumValue)(index_1.PaginationControllerType, reaction.type)
        };
    }
}
exports.ReactionPaginationBuilder = ReactionPaginationBuilder;
//# sourceMappingURL=ReactionPaginationBuilder.js.map