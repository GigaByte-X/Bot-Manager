"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BasePagination = void 0;
const discord_js_1 = require("discord.js");
const events_1 = __importDefault(require("events"));
const page_1 = require("../types/page");
const enums_1 = require("../types/enums");
class BasePagination extends events_1.default {
    _pages = [];
    _authorId = null;
    _currentPageIndex = 0;
    _timer = 20000;
    _pagination = null;
    _authorDependent = true;
    _command = null;
    _components = [];
    _paginationComponent = null;
    _disableAllComponents = false;
    _removeAllComponents = false;
    _removePaginationComponents = false;
    get pages() { return this._pages; }
    get currentPageIndex() { return this._currentPageIndex; }
    get currentPage() { return this.getPage(this.currentPageIndex); }
    get timer() { return this._timer; }
    get pagination() { return this._pagination; }
    get authorDependent() { return this._authorDependent; }
    get command() { return this._command; }
    get components() { return this._components; }
    get previousPageIndex() { return this.currentPageIndex - 1 < 0 ? this.pages.length - 1 : this.currentPageIndex - 1; }
    get nextPageIndex() { return this.currentPageIndex + 1 >= this.pages.length ? 0 : this.currentPageIndex + 1; }
    get authorId() {
        if (this._authorId)
            return this._authorId;
        return (this.command instanceof discord_js_1.Message ? this.command.author.id : this.command?.user?.id) || null;
    }
    constructor(options) {
        super();
        options = options.toJSON !== undefined
            ? options.toJSON()
            : options;
        this.setPages(...(options?.pages ?? []));
        this.setAuthorId(options?.authorId);
        this.setAuthorDependent(options.authorDependent ?? this.authorDependent);
        this.setTimer(options?.timer ?? this.timer);
        this._currentPageIndex = options?.currentPageIndex ?? this.currentPageIndex;
    }
    /**
     * Add pages to pagination
     * @param pages array of page data to add
     */
    addPages(...pages) {
        this._pages.push(...BasePagination.resolveStaticPages((0, discord_js_1.normalizeArray)(pages)));
        return this;
    }
    /**
     * Clear and set pagination pages
     * @param pages array of page data
     */
    setPages(...pages) {
        this._pages = BasePagination.resolveStaticPages((0, discord_js_1.normalizeArray)(pages));
        return this;
    }
    /**
     * Pagination will only works for command author
     * @param authorDependent set author dependent
     */
    setAuthorDependent(authorDependent) {
        this._authorDependent = !!authorDependent;
        return this;
    }
    /**
     * Set author id
     * @param author author user resolvable
     */
    setAuthorId(author) {
        this._authorId = typeof author === 'string' ? author : author?.id || null;
        return this;
    }
    /**
     * Add action rows to page components
     * @param components action rows
     */
    addComponents(...components) {
        this._components?.push(...(0, discord_js_1.normalizeArray)(components).map(c => c instanceof discord_js_1.ActionRowBuilder ? c : new discord_js_1.ActionRowBuilder(c)));
        return this;
    }
    /**
     * Set page action rows
     * @param components action rows
     */
    setComponents(...components) {
        this._components = (0, discord_js_1.normalizeArray)(components).map(c => c instanceof discord_js_1.ActionRowBuilder ? c : new discord_js_1.ActionRowBuilder(c));
        return this;
    }
    /**
     * Collector timer
     * @param timer timer in milliseconds
     */
    setTimer(timer) {
        this._timer = timer;
        return this;
    }
    /**
     * Get page data by index
     * @param pageIndex page index
     */
    async getPage(pageIndex) {
        const page = this.pages.find((p, i) => i === pageIndex);
        const pageData = page ? await (0, page_1.resolvePage)(page) : undefined;
        if (!pageData)
            return pageData;
        let components = this._removeAllComponents
            ? []
            : [
                ...(pageData.components ?? []),
                ...this.components,
                ...(this._paginationComponent !== null && !this._removePaginationComponents
                    ? [this._paginationComponent]
                    : [])
            ];
        if (this._disableAllComponents)
            components = components.map(c => {
                if (c === undefined)
                    return c;
                const actionrow = c instanceof discord_js_1.ActionRowBuilder
                    ? c
                    : new discord_js_1.ActionRowBuilder(c);
                actionrow.components.forEach(c => c.setDisabled(true));
                return actionrow;
            });
        return {
            ...pageData,
            components: [
                ...components
            ]
        };
    }
    /**
     * Check if pagination is sent
     */
    isSent() {
        return this.command !== null && this.pagination !== null;
    }
    toJSON() {
        return {
            pages: this.pages,
            authorId: this.authorId,
            currentPageIndex: this.currentPageIndex,
        };
    }
    /**
     * Set current pagination page by index
     * @param pageIndex page index
     */
    async setCurrentPage(pageIndex, editComponentsOnly = false) {
        const page = await (pageIndex !== undefined ? this.getPage(pageIndex) : this.currentPage);
        if (!page)
            throw new RangeError(`Cannot find page index '${pageIndex}'`);
        this._currentPageIndex = pageIndex ?? this.currentPageIndex;
        if (this.isSent()) {
            if (!(this.command instanceof discord_js_1.Message)) {
                await this.command.editReply(!editComponentsOnly ? page : { components: page.components });
            }
            else {
                await this.pagination.edit(!editComponentsOnly ? page : { components: page.components });
            }
            this.emit('pageChange', (await this.currentPage), this.currentPageIndex);
        }
        return page;
    }
    /**
     * Send the pagination message
     * @param page Pagination page
     * @param sendAs Send type
     */
    async _sendPage(page, sendAs) {
        if (!this.command)
            throw new Error(`Pagination command trigger is undefined`);
        switch (sendAs) {
            case enums_1.SendAs.NewMessage:
                if (!this.command.channel)
                    throw new Error(`Pagination command trigger channel id is null`);
                this._pagination = await this.command.channel.send(page);
                return;
            case enums_1.SendAs.EditMessage:
                if (this.command instanceof discord_js_1.Message) {
                    if (!this.command.editable)
                        throw new Error("Can't edit message command");
                    this._pagination = await this.command.edit(page);
                    return;
                }
                else {
                    if (!this.command.replied && !this.command.deferred)
                        throw new Error("Interaction is not replied or deferred");
                    this._pagination = await this.command.editReply(page);
                    return;
                }
            case enums_1.SendAs.ReplyMessage:
                if (this.command instanceof discord_js_1.Message) {
                    this._pagination = await this.command.reply(page);
                    return;
                }
                else {
                    if (this.command.replied || this.command.deferred)
                        throw new Error("Interaction is already replied or deferred");
                    await this.command.reply(page);
                    this._pagination = await this.command.fetchReply();
                    return;
                }
        }
    }
    /**
     * Resolve pagination pages except for dynamic page functions
     * @param pages resolvable pages
     */
    static resolveStaticPages(...pages) {
        return (0, discord_js_1.normalizeArray)(pages).map(p => typeof p === 'function' ? p : (0, page_1.resolvePage)(p));
    }
    /**
     * Resolve pagination pages
     * @param pages resolvable pages
     */
    static async resolvePages(...pages) {
        return Promise.all((0, discord_js_1.normalizeArray)(pages).map(p => (0, page_1.resolvePage)(p)));
    }
}
exports.BasePagination = BasePagination;
//# sourceMappingURL=BasePagination.js.map